name: Rekor Keyless Demo

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - ".fide/statement-attestations/**"
      - ".github/workflows/rekor-keyless-demo.yml"

permissions:
  contents: read
  id-token: write

concurrency:
  group: rekor-keyless-${{ github.ref }}
  cancel-in-progress: true

jobs:
  sign-and-verify:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Detect newly added statement-attestations in this push
        id: changes
        shell: bash
        run: |
          set -euo pipefail

          if [ "${{ github.event_name }}" = "push" ]; then
            before="${{ github.event.before }}"
            after="${{ github.sha }}"
            if [ -z "${before}" ] || [ "${before}" = "0000000000000000000000000000000000000000" ]; then
              before="$(git rev-list --max-parents=0 HEAD | tail -n 1)"
            fi
          else
            # manual dispatch fallback
            before="$(git rev-parse HEAD~1)"
            after="$(git rev-parse HEAD)"
          fi

          mapfile -t lines < <(git diff --name-status "${before}" "${after}" -- ".fide/statement-attestations")
          if [ "${#lines[@]}" -eq 0 ]; then
            echo "No attestation path changes in this range."
            echo "has_new=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          added=()
          invalid=()
          for line in "${lines[@]}"; do
            status="$(awk '{print $1}' <<<"${line}")"
            path="$(awk '{print $2}' <<<"${line}")"
            if [[ "${path}" != *.json ]]; then
              continue
            fi
            if [ "${status}" = "A" ]; then
              added+=("${path}")
            else
              invalid+=("${line}")
            fi
          done

          if [ "${#invalid[@]}" -gt 0 ]; then
            echo "Invalid non-additive attestation changes detected:"
            printf '  %s\n' "${invalid[@]}"
            exit 1
          fi

          if [ "${#added[@]}" -eq 0 ]; then
            echo "No newly added attestation files in this push."
            echo "has_new=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has_new=true" >> "$GITHUB_OUTPUT"
          {
            echo "files<<EOF"
            printf '%s\n' "${added[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          echo "New attestation files:"
          printf '  %s\n' "${added[@]}"

      - name: Attest blob keylessly as DSSE (Rekor v2 hybrid)
        id: sign
        if: steps.changes.outputs.has_new == 'true'
        shell: bash
        env:
          FCP_PREDICATE_TYPE: https://fide.work/fcp/predicate/statement-attestation/v1
          REKOR_V2_URL: https://log2025-1.rekor.sigstore.dev
          TSA_URL: https://timestamp.sigstore.dev/api/v1/timestamp
          PROOF_WEBHOOK_URL: https://webhook.site/19378ebb-2919-4ec1-8c18-9573661101be
          WORKFLOW_TEMP_DIR: .fide-temp-workflow
          CERT_ID_RE: ^https://github.com/${{ github.repository }}/.github/workflows/rekor-keyless-demo.yml@refs/heads/${{ github.ref_name }}$
        run: |
          set -euo pipefail
          tsa_flag=""
          if cosign attest-blob --help | grep -q -- "--rfc3161-timestamp-bundle"; then
            tsa_flag="--rfc3161-timestamp-bundle"
          elif cosign attest-blob --help | grep -q -- "--rfc3161-timestamp"; then
            tsa_flag="--rfc3161-timestamp"
          else
            echo "No supported RFC3161 timestamp output flag found in this cosign version"
            cosign version || true
            exit 1
          fi

          while IFS= read -r ATTESTATION_FILE; do
            [ -z "${ATTESTATION_FILE}" ] && continue
            base="$(basename "${ATTESTATION_FILE}")"
            base_noext="${base%.json}"
            stamp="$(date -u +%Y-%m-%dT%H-%M-%S.%3NZ)"
            outdir=".fide/rekor-proofs/$(date -u +%Y/%m/%d)"
            mkdir -p "${outdir}"
            mkdir -p "${WORKFLOW_TEMP_DIR}"
            tmpdir="${WORKFLOW_TEMP_DIR}/${stamp}--${base_noext}"
            mkdir -p "${tmpdir}"
            bundle="${outdir}/${base_noext}.sigstore.json"
            tsa="${outdir}/${base_noext}.rfc3161.tsr"
            rekor="${outdir}/${base_noext}.rekor-v2.json"
            cert_file="${tmpdir}/cert.pem"
            envelope_file="${tmpdir}/envelope.json"
            payload_file="${tmpdir}/rekor_v2_payload.json"
            predicate_file="${tmpdir}/predicate.json"

            ATTESTATION_FILE="${ATTESTATION_FILE}" PREDICATE_FILE="${predicate_file}" node -e "const fs=require('fs'); const p=process.env.ATTESTATION_FILE; const a=JSON.parse(fs.readFileSync(p,'utf8')); const pred={attestation:{m:a.m,u:a.u,r:a.r,s:a.s},source:{path:p}}; fs.writeFileSync(process.env.PREDICATE_FILE, JSON.stringify(pred));"

            cosign attest-blob \
              --yes \
              --tlog-upload=false \
              --timestamp-server-url "${TSA_URL}" \
              "${tsa_flag}" "${tsa}" \
              --predicate "${predicate_file}" \
              --type "${FCP_PREDICATE_TYPE}" \
              --bundle "${bundle}" \
              --output-certificate "${cert_file}" \
              "${ATTESTATION_FILE}" > "${envelope_file}"

            RAW_ENVELOPE_JSON="$(jq -c '
              first(
                .. | objects |
                select(
                  (has("payloadType") or has("payload_type")) and
                  has("signatures") and
                  (has("payload") or has("base64Payload") or has("payloadBytes"))
                )
                ) // empty
              ' "${envelope_file}" 2>/dev/null || true)"
            if [ -z "${RAW_ENVELOPE_JSON}" ]; then
              RAW_ENVELOPE_JSON="$(jq -c '
                first(
                  .. | objects |
                  select(
                    (has("payloadType") or has("payload_type")) and
                    has("signatures") and
                    (has("payload") or has("base64Payload") or has("payloadBytes"))
                  )
                ) // empty
              ' "${bundle}" 2>/dev/null || true)"
            fi
            if [ -z "${RAW_ENVELOPE_JSON}" ]; then
              echo "Could not find DSSE envelope in bundle JSON"
              echo "Envelope file top-level keys:"
              jq -c 'keys' "${envelope_file}" || true
              echo "Bundle top-level keys:"
              jq -c 'keys' "${bundle}" || true
              exit 1
            fi

            ENVELOPE_JSON="$(jq -cn --argjson e "${RAW_ENVELOPE_JSON}" '
              {
                payload: ($e.payload // $e.base64Payload // $e.payloadBytes),
                payloadType: ($e.payloadType // $e.payload_type),
                signatures: (($e.signatures // []) | map({
                  sig: (.sig // .base64Signature),
                  keyid: (.keyid // .keyId // "")
                }))
              }
            ')"
            CERT_B64="$(openssl x509 -in "${cert_file}" -outform DER | base64 -w0)"
            if [ -z "${ENVELOPE_JSON}" ] || [ "${ENVELOPE_JSON}" = "null" ]; then
              echo "Missing dsseEnvelope in bundle"
              exit 1
            fi
            if ! jq -e '.payload and .payloadType and (.signatures | length > 0) and (.signatures | all(.sig))' >/dev/null 2>&1 <<<"${ENVELOPE_JSON}"; then
              echo "Normalized envelope missing required DSSE fields"
              echo "${ENVELOPE_JSON}"
              exit 1
            fi
            if [ -z "${CERT_B64}" ] || [ "${CERT_B64}" = "null" ]; then
              echo "Missing certificate bytes"
              exit 1
            fi

            jq -n \
              --argjson envelope "${ENVELOPE_JSON}" \
              --arg certB64 "${CERT_B64}" \
              '{
                dsseRequestV002: {
                  envelope: $envelope,
                  verifiers: [
                    {
                      x509Certificate: { rawBytes: $certB64 },
                      keyDetails: "PKIX_ECDSA_P256_SHA_256"
                    }
                  ]
                }
              }' > "${payload_file}"

            http_code="$(curl -sS -o "${tmpdir}/rekor_http_response.json" -w "%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              --data @"${payload_file}" \
              "${REKOR_V2_URL}/api/v2/log/entries")"
            if [ "${http_code}" -lt 200 ] || [ "${http_code}" -ge 300 ]; then
              echo "Rekor v2 upload failed with HTTP ${http_code}"
              cat "${tmpdir}/rekor_http_response.json"
              exit 1
            fi

            cosign verify-blob-attestation \
              --insecure-ignore-tlog \
              --bundle "${bundle}" \
              --type "${FCP_PREDICATE_TYPE}" \
              --certificate-identity-regexp "${CERT_ID_RE}" \
              --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
              "${ATTESTATION_FILE}"

            cp "${tmpdir}/rekor_http_response.json" "${rekor}"
            cp "${rekor}" ".fide/rekor-proofs/latest.rekor-v2.json"
            cp "${bundle}" ".fide/rekor-proofs/latest.attestation.sigstore.json"
            cp "${tsa}" ".fide/rekor-proofs/latest.attestation.rfc3161.tsr"

            attestation_json="$(cat "${ATTESTATION_FILE}")"
            attestation_m="$(jq -r '.m // empty' <<<"${attestation_json}")"
            attestation_u="$(jq -r '.u // empty' <<<"${attestation_json}")"
            attestation_r="$(jq -r '.r // empty' <<<"${attestation_json}")"
            attestation_s="$(jq -r '.s // empty' <<<"${attestation_json}")"

            webhook_payload="$(jq -n \
              --arg repo "${{ github.repository }}" \
              --arg sha "${{ github.sha }}" \
              --arg runId "${{ github.run_id }}" \
              --arg attestationM "${attestation_m}" \
              --arg attestationU "${attestation_u}" \
              --arg attestationR "${attestation_r}" \
              --arg attestationS "${attestation_s}" \
              --arg tsaTokenB64 "$(base64 -w0 "${tsa}")" \
              --argjson rekorResponse "$(cat "${rekor}")" \
              '{
                repo: $repo,
                sha: $sha,
                runId: $runId,
                items: [
                  {
                    attestation: {
                      m: $attestationM,
                      u: $attestationU,
                      r: $attestationR,
                      s: $attestationS
                    },
                    rekor: {
                      logIndex: ($rekorResponse.logIndex // null),
                      logId: ($rekorResponse.logId.keyId // null),
                      inclusionProof: {
                        logIndex: ($rekorResponse.inclusionProof.logIndex // null),
                        treeSize: ($rekorResponse.inclusionProof.treeSize // null),
                        checkpointEnvelope: ($rekorResponse.inclusionProof.checkpoint.envelope // null)
                      }
                    },
                    tsa: {
                      tokenB64: $tsaTokenB64
                    }
                  }
                ]
              }')"

            curl -sS -X POST \
              -H "Content-Type: application/json" \
              --data "${webhook_payload}" \
              "${PROOF_WEBHOOK_URL}" >/dev/null || echo "Webhook POST failed; continuing."

            echo "Processed: ${ATTESTATION_FILE}"
            echo "  Rekor response: ${rekor}"
            echo "  Bundle: ${bundle}"
            rm -rf "${tmpdir}"
          done <<< "${{ steps.changes.outputs.files }}"

      - name: Upload Rekor proof artifacts
        if: steps.changes.outputs.has_new == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: rekor-keyless-proofs
          path: .fide/rekor-proofs/**
          retention-days: 7
